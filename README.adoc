

= JGroups and Docker
:author: Bela Ban belaban@yahoo.com
#:backend: deckjs
#:deckjs_transition: fade
:navigation:
:deckjs_theme: web-2.0
:deckjs_transition: fade
:goto:
:menu:
:toc:
:status:

== Overview
This document describes how to use JGroups in Docker containers to form clusters locally,
on Amazon Web Services (AWS) and in the Google cloud (Google Compute Platform, GCP).

The advantage of running Docker images in the cloud, rather than cloud-specific images is that the Docker
images are the same across different clouds, whereas cloud images are always specific to a given cloud.

The predefined docker image we'll use is https://hub.docker.com/r/belaban/jgroups]. It contains a number
of interactive <<demos>>, ie. demos which require a TTY.

The difference between running locally, or running in a cloud lies in the JGroups configuration and the Docker
startup options. Clouds generally do not support IP multicasting, so JGroups applications have to resort to
TCP rather than UDP as transport. Plus, PING cannot be used and has to be replaced with different discovery protocols,
e.g. S3_PING or GOOGLE_PING.

=== Bridged versus host network

Docker supports `none`, `bridge` and `host` networks out of the box (https://docs.docker.com/engine/userguide/networking).
Which type of network is used is defined by the `--network` option, e.g. `--network=host`.

Network `none` has no communication to the outside world and is used purely for Docker containers running on the same
box.

Network `bridge` is the default and can be used for containers to talk to each other. This is done via a `bridge0` or
`docker0` virtual network interface installed by Docker on the host.


** Local
** Network: bridged, host

== Amazon Web Services (AWS)
** S3 buckets for discovery
*** external_addr (bridged network)
** Other discovery mechanisms
*** Route 53
*** Elstic IP addresses
*** GossipRouter
*** Block of addresses in VPC
** IAM security roles (S3 access)
** Security policies (inbound and outbound traffic, open ports)
* Publish ports

== Google Compute Platform (GCP)


[[demos]]
== Demos

To run the image directly, execute

      docker run -p 7800:7800 -p 9000:9000 -it --rm --network=host belaban/jgroups

      or

      docker run -p 7800:7800 -p 9000:9000 -it --rm --network=bridge belaban/jgroups


To build the image, run

      docker build .


The demos are described below. The idea is to run the demo apps in a
container each *on the same host* and they will form a cluster.


=== Chat
To run it:

      chat [-props config] [-name name], e.g. chat -props ./udp.xml -name A

Run the Chat application in multiple containers on the same host and
they will form a cluster. Typing a message into one Chat will send it
to all other chats


=== Distributed locks

Distributed locks are implementations of
`java.util.concurrent.locks.Lock` and provide locks that can be
accessed from all nodes in a cluster. 

A typical use case is to lock a resource so that only 1 thread in a
given node in the cluster can access it. Should a node crash while
holding a lock, the lock is released immediately.

For more details, see the section on distributed locks at
http://www.jgroups.org/manual/index.html#LockService.

To run the lock demo, type:

       lock [-name  name]

Typing `help` into the shell shows a few commands:

    [jgroups@b21d0fa6c79d ~]$ lock -name A

    -------------------------------------------------------------------
    GMS: address=A, cluster=lock-cluster, physical address=172.17.0.178:52519
    -------------------------------------------------------------------
    : help

    LockServiceDemo [-props properties] [-name name]
    Valid commands:
        lock (<lock name>)+
        unlock (<lock name> | "ALL")+
        trylock (<lock name>)+ [<timeout>]

    Example:
        lock lock lock2 lock3
        unlock all
        trylock bela michelle 300
    :

If you start instances A and B, you can try out the following:

1. A: `lock printer`
2. B: `lock printer`   // will block
3. A: `unlock printer` // now B will get the lock

Or a lock holder can be killed:

1. A: `lock printer`
2. B: `lock printer`
3. Kill A. B will now get the lock on "printer"

    



=== Distributed counters

Distributed counters are counters will can be atomically incremented,
decremented, compare-and-set etc *across a cluster*.

To run the demo:

    count [-name name]

Run multiple instances in different containers. The demo uses a
counter named "mycounter" and there's a command prompt which shows the
commands to be executed.


Questions can be asked on the users or dev mailing lists:
https://sourceforge.net/p/javagroups/mailman.

Enjoy !

Bela Ban


